<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBTC PoW Miner - BSC Testnet</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            max-width: 800px; 
            margin: 0 auto;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 { 
            color: #f39c12; 
            font-size: 2.2em;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: #ecf0f1;
            font-size: 1em;
            opacity: 0.8;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .status-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-box.connected {
            border-left: 4px solid #27ae60;
            background: rgba(39, 174, 96, 0.1);
        }
        
        .status-box.disconnected {
            border-left: 4px solid #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }
        
        .status-label {
            font-size: 0.85em;
            color: #bdc3c7;
            margin-bottom: 5px;
        }
        
        .status-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .mining-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 20px 0;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #f39c12;
            margin: 8px 0;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #95a5a6;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        
        button { 
            padding: 12px 16px; 
            cursor: pointer; 
            border: none; 
            border-radius: 8px; 
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #connectBtn { 
            background: linear-gradient(45deg, #3498db, #2980b9); 
            color: white; 
        }
        
        #mineBtn { 
            background: linear-gradient(45deg, #27ae60, #229954); 
            color: white; 
        }
        
        #mineBtn.mining { 
            background: linear-gradient(45deg, #e74c3c, #c0392b); 
        }
        
        #testBtn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .rewards-section {
            background: rgba(155, 89, 182, 0.15);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(155, 89, 182, 0.4);
            margin: 15px 0;
            display: none;
        }
        
        .rewards-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .rewards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .rewards-info {
            flex: 1;
        }
        
        .rewards-amount {
            font-size: 1.4em;
            font-weight: bold;
            color: #9b59b6;
            margin-bottom: 5px;
        }
        
        .rewards-label {
            font-size: 0.8em;
            color: #bdc3c7;
        }
        
        #claimBtn {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            color: white;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 8px;
            min-width: 120px;
        }
        
        #claimBtn:hover:not(:disabled) {
            background: linear-gradient(45deg, #8e44ad, #7d3c98);
        }
        
        #claimBtn:disabled {
            background: #7f8c8d;
        }
        
        .claim-info {
            font-size: 0.75em;
            color: #bdc3c7;
            text-align: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .test-section {
            background: rgba(243, 156, 18, 0.15);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(243, 156, 18, 0.4);
            margin: 15px 0;
            text-align: center;
        }
        
        .test-info {
            font-size: 0.8em;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .log-section {
            margin-top: 20px;
        }
        
        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        #activityLog { 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            padding: 12px; 
            min-height: 150px; 
            max-height: 250px;
            overflow-y: auto; 
            background-color: rgba(0, 0, 0, 0.3);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.3;
        }
        
        .log-entry {
            margin-bottom: 4px;
        }
        
        .log-timestamp {
            color: #7f8c8d;
        }
        
        .clear-log {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .success { color: #27ae60; }
        .warning { color: #f39c12; }
        .error { color: #e74c3c; }
        .info { color: #3498db; }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #95a5a6;
            font-size: 0.8em;
        }
        
        @media (max-width: 768px) {
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
            
            .rewards-header {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }
            
            #claimBtn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⛏️ NBTC MINER</h1>
            <div class="subtitle">Proof-of-Work Mining - BSC Testnet</div>
        </div>

        <div class="status-grid">
            <div class="status-box" id="networkStatus">
                <div class="status-label">Jaringan</div>
                <div class="status-value" id="network">Memuat...</div>
            </div>
            
            <div class="status-box disconnected" id="walletStatus">
                <div class="status-label">Dompet</div>
                <div class="status-value" id="address">Belum terhubung</div>
            </div>
        </div>

        <div class="status-box" id="miningInfoBox">
            <div class="status-label">Status Mining</div>
            <div class="status-value" id="minerStatus">Siap Memulai</div>
            
            <div class="mining-stats">
                <div class="stat-item">
                    <div class="stat-label">KESULITAN</div>
                    <div class="stat-value" id="difficulty">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">CHALLENGE ID</div>
                    <div class="stat-value" id="challengeID">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">HADIAH NBTC</div>
                    <div class="stat-value" id="reward">50.0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">HALVING (HARI)</div>
                    <div class="stat-value" id="halvingDays">1459</div>
                </div>
            </div>
        </div>

        <!-- TEST SECTION -->
        <div class="test-section">
            <div class="test-info">🚀 QUICK TEST - Coba nonce yang mungkin work</div>
            <button id="testBtn">🎯 Test Quick Mining</button>
        </div>

        <!-- REWARDS SECTION -->
        <div class="rewards-section" id="rewardsSection">
            <div class="rewards-header">
                <div class="rewards-info">
                    <div class="rewards-amount" id="pendingRewards">0 NBTC</div>
                    <div class="rewards-label">PENDING REWARDS</div>
                </div>
                <button id="claimBtn">💰 Claim Rewards</button>
            </div>
            <div class="claim-info">
                Minimum claim: 10,000 NBTC | Gas fee required
            </div>
        </div>

        <div class="button-group">
            <button id="connectBtn">🔗 Connect Wallet</button>
            <button id="mineBtn" disabled>⛏️ Start Mining</button>
        </div>

        <div class="log-section">
            <div class="log-header">
                <div class="status-label">📋 ACTIVITY LOG</div>
                <button class="clear-log" onclick="clearLog()">🗑️ Clear</button>
            </div>
            <div id="activityLog">
                <div class="log-entry">
                    <span class="log-timestamp">[System]</span> <span class="info">NBTC Miner started...</span>
                </div>
            </div>
        </div>

        <div class="footer">
            NBTC Mining DApp v3.0 | BSC Testnet | Optimized Mining
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    
    <script>
        // Konfigurasi
        const CONTRACT_ADDRESS = "0x8f6868373aAe040E7F41a34F5Ea4E9Eb812DA334";
        const ABI = [
            "function mineBlock(uint256 _nonce) external",
            "function claimReward() external",
            "function canClaimReward(address user) external view returns (bool)",
            "function getPendingReward(address user) external view returns (uint256)",
            "function getMiningInfo() external view returns (uint256, uint256, uint256, uint256, bool, uint256, uint256)",
            "function currentDifficulty() external view returns (uint256)",
            "function currentChallengeID() external view returns (uint256)",
            "function lastBlockTimestamp() external view returns (uint256)",
            "function lastMineTime(address) external view returns (uint256)"
        ];

        let provider, signer, contract, minerWorker, isMining = false;

        // DOM elements
        const difficultyElement = document.getElementById('difficulty');
        const challengeIDElement = document.getElementById('challengeID');
        const rewardElement = document.getElementById('reward');
        const halvingDaysElement = document.getElementById('halvingDays');
        const minerStatusElement = document.getElementById('minerStatus');
        const pendingRewardsElement = document.getElementById('pendingRewards');
        const rewardsSection = document.getElementById('rewardsSection');
        const claimBtn = document.getElementById('claimBtn');
        const testBtn = document.getElementById('testBtn');

        // Initialize
        window.addEventListener('load', initializeApp);

        async function initializeApp() {
            if (typeof window.ethereum === 'undefined') {
                return logActivity('❌ Install MetaMask to use this dApp', 'error');
            }

            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                // Event listeners
                window.ethereum.on('accountsChanged', (accounts) => {
                    accounts.length > 0 ? connectWallet() : disconnectWallet();
                });

                window.ethereum.on('chainChanged', () => {
                    window.location.reload();
                });

                // Check if already connected
                const accounts = await provider.listAccounts();
                if (accounts.length > 0) {
                    await connectWallet();
                }

                await updateNetworkInfo();
                logActivity('✅ DApp ready! Connect your wallet to start mining.', 'success');

            } catch (error) {
                logActivity('❌ Initialization error: ' + error.message, 'error');
            }
        }

        async function connectWallet() {
            try {
                logActivity('🔄 Connecting to wallet...', 'info');
                
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                signer = provider.getSigner();
                const address = await signer.getAddress();
                
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
                
                // Update UI
                document.getElementById('address').textContent = `${address.substring(0, 6)}...${address.substring(38)}`;
                walletStatus.className = 'status-box connected';
                connectBtn.textContent = '✅ Connected';
                connectBtn.disabled = true;
                mineBtn.disabled = false;
                testBtn.disabled = false;
                
                await updateMiningInfo();
                logActivity(`✅ Successfully connected: ${address}`, 'success');
                
            } catch (error) {
                logActivity('❌ Failed to connect wallet: ' + error.message, 'error');
            }
        }

        function disconnectWallet() {
            if (isMining) stopMining();
            
            signer = null;
            contract = null;
            document.getElementById('address').textContent = 'Not connected';
            walletStatus.className = 'status-box disconnected';
            connectBtn.textContent = '🔗 Connect Wallet';
            connectBtn.disabled = false;
            mineBtn.disabled = true;
            testBtn.disabled = true;
            rewardsSection.classList.remove('active');
            
            logActivity('🔌 Wallet disconnected', 'warning');
        }

        async function updateNetworkInfo() {
            try {
                if (!provider) return;
                
                const network = await provider.getNetwork();
                const chainId = network.chainId;
                
                let networkName = 'Unknown Network';
                if (chainId === 56) networkName = 'BSC Mainnet';
                else if (chainId === 97) networkName = 'BSC Testnet';
                else if (chainId === 1) networkName = 'Ethereum Mainnet';
                
                document.getElementById('network').textContent = `${networkName} (${chainId})`;
                networkStatus.className = chainId === 97 ? 'status-box connected' : 'status-box disconnected';
                
                if (chainId !== 97) {
                    logActivity('⚠️ Please switch to BSC Testnet (ChainID: 97)', 'warning');
                }
                
            } catch (error) {
                document.getElementById('network').textContent = 'Network Error';
                networkStatus.className = 'status-box disconnected';
            }
        }

        async function updateMiningInfo() {
            try {
                if (!contract) return;
                
                // Try to get mining info
                const miningData = await contract.getMiningInfo();
                console.log('Mining data:', miningData);
                
                // Update basic info
                difficultyElement.textContent = miningData[0].toString();
                challengeIDElement.textContent = miningData[1].toString();
                rewardElement.textContent = ethers.utils.formatUnits(miningData[2], 8);
                halvingDaysElement.textContent = Math.floor(miningData[3] / 86400).toLocaleString();
                minerStatusElement.textContent = miningData[4] ? 'Ready to Mine' : 'In Cooldown';
                
                // Update rewards section
                const pendingRewards = ethers.utils.formatUnits(miningData[5], 8);
                const minClaimAmount = ethers.utils.formatUnits(miningData[6], 8);
                
                pendingRewardsElement.textContent = parseFloat(pendingRewards).toLocaleString() + ' NBTC';
                
                // Show/hide rewards section
                if (parseFloat(pendingRewards) > 0) {
                    rewardsSection.classList.add('active');
                    
                    // Check if can claim
                    const canClaim = parseFloat(pendingRewards) >= parseFloat(minClaimAmount);
                    claimBtn.disabled = !canClaim;
                    
                    if (canClaim) {
                        claimBtn.innerHTML = '💰 Claim Rewards';
                        claimBtn.title = 'Click to claim your rewards';
                    } else {
                        const needed = (parseFloat(minClaimAmount) - parseFloat(pendingRewards)).toLocaleString();
                        claimBtn.innerHTML = `⏳ Need ${needed} more`;
                        claimBtn.title = `Minimum ${minClaimAmount} NBTC required to claim`;
                    }
                } else {
                    rewardsSection.classList.remove('active');
                }
                
            } catch (error) {
                console.error('Mining info error:', error);
                logActivity('⚠️ Using fallback data (getMiningInfo failed)', 'warning');
                
                // Fallback: get individual data
                try {
                    const difficulty = await contract.currentDifficulty();
                    const challengeID = await contract.currentChallengeID();
                    
                    difficultyElement.textContent = difficulty.toString();
                    challengeIDElement.textContent = challengeID.toString();
                    
                    // Try to get pending rewards individually
                    const address = await signer.getAddress();
                    const pendingRewards = await contract.getPendingReward(address);
                    const pendingAmount = ethers.utils.formatUnits(pendingRewards, 8);
                    
                    if (parseFloat(pendingAmount) > 0) {
                        pendingRewardsElement.textContent = parseFloat(pendingAmount).toLocaleString() + ' NBTC';
                        rewardsSection.classList.add('active');
                        
                        // Check if can claim
                        const canClaim = await contract.canClaimReward(address);
                        claimBtn.disabled = !canClaim;
                    }
                    
                } catch (fallbackError) {
                    logActivity('❌ Failed to get mining data', 'error');
                }
            }
        }

        // Event listeners
        connectBtn.addEventListener('click', connectWallet);
        mineBtn.addEventListener('click', toggleMining);
        claimBtn.addEventListener('click', claimRewards);
        testBtn.addEventListener('click', quickTestMining);

        function toggleMining() {
            if (isMining) {
                stopMining();
            } else {
                startMining();
            }
        }

        function startMining() {
            if (!contract || !signer) {
                logActivity('❌ Please connect your wallet first', 'error');
                return;
            }
            
            // Check network
            provider.getNetwork().then(network => {
                if (network.chainId !== 97) {
                    logActivity('❌ Please switch to BSC Testnet (ChainID: 97)', 'error');
                    return;
                }
            });
            
            isMining = true;
            mineBtn.textContent = '🛑 Stop Mining';
            mineBtn.classList.add('mining');
            minerStatusElement.textContent = 'Mining Active...';
            
            // Start Web Worker
            minerWorker = new Worker('worker.js');
            
            minerWorker.onmessage = async function(event) {
                const { nonce, hash, found, error } = event.data;
                
                if (error) {
                    logActivity('❌ Mining worker error: ' + error, 'error');
                    return;
                }
                
                if (found) {
                    logActivity(`🎉 VALID SOLUTION FOUND! Nonce: ${nonce}`, 'success');
                    logActivity(`🔑 Hash: ${hash}`, 'info');
                    
                    try {
                        // Submit to blockchain
                        const tx = await contract.mineBlock(nonce);
                        logActivity(`📝 Transaction submitted: ${tx.hash}`, 'info');
                        
                        const receipt = await tx.wait();
                        logActivity(`✅ Block successfully mined! Gas used: ${receipt.gasUsed.toString()}`, 'success');
                        
                        // Update mining info
                        await updateMiningInfo();
                        
                    } catch (error) {
                        if (error.message.includes('cooldown')) {
                            logActivity('⏳ Cooldown active, please wait 30 seconds', 'warning');
                            stopMining();
                        } else if (error.message.includes('Invalid hash')) {
                            logActivity('❌ Hash validation failed', 'error');
                        } else if (error.message.includes('insufficient funds')) {
                            logActivity('❌ Insufficient BNB for gas fees', 'error');
                            stopMining();
                        } else {
                            logActivity('❌ Mining transaction failed: ' + error.message, 'error');
                        }
                    }
                } else {
                    // Log progress occasionally
                    if (nonce % 50000 === 0) {
                        logActivity(`⛏️ Testing nonce: ${nonce.toLocaleString()}...`, 'info');
                    }
                }
            };
            
            // Send mining data to worker
            getMiningDataForWorker();
            logActivity('⛏️ Mining started with MATCHED algorithm...', 'info');
        }

        function stopMining() {
            if (minerWorker) {
                minerWorker.terminate();
                minerWorker = null;
            }
            
            isMining = false;
            mineBtn.textContent = '⛏️ Start Mining';
            mineBtn.classList.remove('mining');
            minerStatusElement.textContent = 'Mining Stopped';
            logActivity('⏹️ Mining stopped', 'warning');
        }

        async function getMiningDataForWorker() {
            try {
                const address = await signer.getAddress();
                const challengeID = await contract.currentChallengeID();
                const lastBlockTimestamp = await contract.lastBlockTimestamp();
                const difficulty = await contract.currentDifficulty();
                const chainId = (await provider.getNetwork()).chainId;
                
                minerWorker.postMessage({
                    type: 'START',
                    address: address,
                    challengeID: challengeID.toString(),
                    lastBlockTimestamp: lastBlockTimestamp.toString(),
                    difficulty: difficulty.toString(),
                    chainId: chainId.toString()
                });
                
                logActivity(`📊 Mining parameters - Difficulty: ${difficulty}, Challenge: ${challengeID}`, 'info');
                
            } catch (error) {
                logActivity('❌ Failed to get mining parameters: ' + error.message, 'error');
            }
        }

        // QUICK TEST FUNCTION - Try known nonces
        async function quickTestMining() {
            if (!contract || !signer) {
                logActivity('❌ Please connect wallet first', 'error');
                return;
            }

            testBtn.disabled = true;
            testBtn.textContent = '🎯 Testing...';
            
            logActivity('🚀 Starting quick test with known nonces...', 'info');
            
            // Try a range of nonces that might work
            const testNonces = [1, 10, 100, 1000, 10000, 100000, 123456, 654321, 999999];
            
            for (const nonce of testNonces) {
                try {
                    logActivity(`🔍 Testing nonce: ${nonce}...`, 'info');
                    const tx = await contract.mineBlock(nonce);
                    logActivity(`🎉 SUCCESS! Nonce ${nonce} worked! Tx: ${tx.hash}`, 'success');
                    
                    const receipt = await tx.wait();
                    logActivity(`✅ Block mined! Gas: ${receipt.gasUsed.toString()}`, 'success');
                    
                    await updateMiningInfo();
                    break;
                    
                } catch (error) {
                    if (error.message.includes('Invalid hash')) {
                        // Continue to next nonce
                        continue;
                    } else if (error.message.includes('cooldown')) {
                        logActivity('⏳ Cooldown active', 'warning');
                        break;
                    } else {
                        logActivity(`❌ Nonce ${nonce} failed: ${error.message}`, 'error');
                    }
                }
            }
            
            testBtn.disabled = false;
            testBtn.textContent = '🎯 Test Quick Mining';
            logActivity('🏁 Quick test completed', 'info');
        }

        async function claimRewards() {
            try {
                if (!contract) {
                    logActivity('❌ Please connect wallet first', 'error');
                    return;
                }
                
                const address = await signer.getAddress();
                
                // Check if can claim
                const canClaim = await contract.canClaimReward(address);
                if (!canClaim) {
                    logActivity('❌ Minimum 10,000 NBTC required to claim', 'error');
                    return;
                }
                
                // Get pending amount for confirmation
                const pendingAmount = await contract.getPendingReward(address);
                const pendingFormatted = ethers.utils.formatUnits(pendingAmount, 8);
                
                claimBtn.disabled = true;
                claimBtn.innerHTML = '⏳ Claiming...';
                
                logActivity(`💰 Claiming ${parseFloat(pendingFormatted).toLocaleString()} NBTC...`, 'info');
                
                const tx = await contract.claimReward();
                logActivity(`📝 Claim transaction sent: ${tx.hash}`, 'info');
                
                const receipt = await tx.wait();
                logActivity(`✅ Successfully claimed ${parseFloat(pendingFormatted).toLocaleString()} NBTC!`, 'success');
                
                // Update UI
                await updateMiningInfo();
                
                claimBtn.innerHTML = '💰 Claim Rewards';
                claimBtn.disabled = false;
                
            } catch (error) {
                logActivity('❌ Claim failed: ' + error.message, 'error');
                claimBtn.disabled = false;
                claimBtn.innerHTML = '💰 Claim Rewards';
            }
        }

        function logActivity(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
            activityLog.appendChild(logEntry);
            activityLog.scrollTop = activityLog.scrollHeight;
        }

        function clearLog() {
            activityLog.innerHTML = '<div class="log-entry"><span class="log-timestamp">[System]</span> <span class="info">Log cleared</span></div>';
        }

        // Auto-update mining info every 30 seconds
        setInterval(() => {
            if (contract && signer) {
                updateMiningInfo();
            }
        }, 30000);
    </script>
</body>
</html>
